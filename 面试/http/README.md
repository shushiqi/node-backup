## http 和 https

|          |  http  | https  |
| :------: | :----: | :----: |
|  安全性  |   低   |   高   |
| 标准端口 |   80   |  443   |
| 网络模型 | 应用层 | 传输层 |
|   证书   |   无   |  需要  |

#### get 和 post

|              |    get     |     post     |
| :----------: | :--------: | :----------: |
|  浏览器回退  |    无害    | 再次发起请求 |
|     缓存     | 浏览器主动 |  需手动设置  |
|   请求参数   |  历史记录  |   不会保留   |
|   参数传递   |    url     | Request body |
|   参数长度   |    限制    |    无限制    |
| 参数数据类型 |   ASCII    |    无限制    |
|     编码     |    url     |   多种方式   |
|   参数长度   |    限制    |    无限制    |

#### http 状态码

    1xx: 指示信息——表示请求已接收，继续处理
    2xx: 成功——表示请求已被成功接收
    3xx: 重定向——表示要完成请求必须进行进一步操作
    4xx: 客户端错误——表示请求有语法错误或请求无法实现
    5xx: 服务端错误——表示服务器未能实现合法的请求
    常用状态码
     200 响应成功
     301 永久重定向
     302 临时重定向
     304 资源缓存
     403 服务器禁止访问
     404 资源不存在
     500 502服务器内部错误
     504 服务器繁忙

### 浏览器从输入 url 到渲染页面，发生了什么？

1. 构建请求
2. (查找缓存)DNS 解析
3. 建立 TCP 连接(三次握手)
4. 发送请求
5. 解析资源(解析 html 构建 DOM 树，解析 css 构建 css 树，生成布局树 `Layout tree`)[过程](../%E9%97%AE%E9%A2%98//%E9%9C%80%E6%B1%82%E9%97%AE%E9%A2%98.md#浏览器渲染过程)
6. 渲染
7. 断开连接(四次挥手)

### 三次握手、四次挥手[查看](https://juejin.cn/post/6844903625513238541)

    - 三次握手：
        1. 客户端发送 `SYN报文`(随机序列号Sep=X) 给服务器；
        2. 服务器接收到报文后，确认了客户端的发送能力，返回`SYN+ACK报文`(ACK = X+1 以及新的随机序列号Y)给客户端；
        3. 客户端接收到报文后，确认了服务器的发送能力、接收能力，返回`ACK报文`(ACK = Y+1，以及新的随机序列号Z)给服务器；
        4. 服务器接收到报文后，确认了客户端的接收能力。

    - 四次挥手(终止连接)
     1. 主动方发送 `FIN+ACK报文` 给被动方；                 主动方：FIN_WAIT_1 被动方:ESTABLISHED
     2. 被动方发送`ACK报文`给主动方；                       主动方：FIN_WAIT_1 被动方:CLOSE_WAIT
     3. 被动方发送`FIN`给主动方                             主动方：FIN_WAIT_2 被动方:LAST_ACK
     4. 主动方发送`ACK报文`给被动方；                       主动方：TIME_WAIT  被动方:LAST_ACK
     5. 被动方接收到报文后；                                主动方：TIME_WAIT  被动方:CLOSE
     6. 主动方在`主动方：TIME_WAIT`等待2MSL后，进入CLOSE状态  主动方：CLOSE  被动方:CLOSE
     > MSL:Maxinum Segment Lifetime 报文段最大生成时间 2分钟

### 跨域

    - 同源策略:出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用
    - 什么时候产生跨域：当协议(protocol)、域名(主机host)、端口(port)任意一项不同时，即产生了跨域
    - 跨域调用
        1. JSONP:<script> 标签元素不受同源策略影响， 加载跨域服务器上的脚本，只支持`GET`请求
        2. CORS:跨域资源共享，是一种规范，指定了跨域资源共享的方式，使用额外的HTTP头让浏览器允许访问来自不同源服务器上的指定资源
            - CORS中存在简单请求与复杂请求
                - 简单请求:`GET``HEAD``POST`
                - 复杂请求:除简单请求以外的请求，当为复杂请求时，浏览器会发出一个`OPTIONS`请求，询问服务器是否支持跨域资源共享
        3. 代理
            - 正向代理：利用服务器端不存在跨域的特性，让接口和当前站点同域，此时代理的是浏览器，例如开发时Webpack设置的devServer
            - 反向代理：代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器，此时代理的是服务器，例如Nginx
        4. 其他
            - document.domain + Iframe
            - window.location.hash + Iframe
            - window.postMessage
    - 为什么服务器端不会有跨域问题？客户端和服务器端都是没有跨域限制的，是因为浏览器限制了服务器返回的数据，防止CSRF（跨站请求伪造） 攻击
